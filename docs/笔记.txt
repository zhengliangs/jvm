在java代码中，类型的加载、连接与初始化都是在程序运行期间完成的。<runtime>
这样做提供了更大的灵活性，增加了更多的可能性。

加载：
	查找并加载类的二进制数据
	将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后创建一个java.lang.Class对象，用来封装类在方法区的数据结构
连接：
	验证：确保被加载的类的正确习
	准备：为类的静态变量分配内存，并将其初始化为默认值
	解析：把类中的符号引用转换为直接引用
初始化：
	为类的静态变量赋予正确的初始值
	
Java虚拟机和程序的生命周期，在以下情况，java虚拟机将会结束生命
	1. 在程序中执行System.exit()
	2. 程序正常运行结束
	3. 在执行过程中遇到了异常或者错误而异常终止
	4. 由于操作系统的错误而导致java虚拟机进程结束

Java程序对类的使用可分为两种方式
	1. 主动使用
	2. 被动使用
所有的Java虚拟机实现必须在每个类或者接口被Java程序“首次主动使用”时才初始化他们

主动使用有七种
	1. 创建类的实例   new Object()
	2. 访问某个类或接口的静态变量，或对该静态变量赋值
	3. 调用类的静态方法
	4. 反射（Class.forName("类的路径")）
	5. 初始化一个类的子类
	6. Java虚拟机启动时被标明为启动类的类
	7. JDK1.7开始提供的动态语言支持
除了以上7中情况，其它使用Java类的方式都被看被动使用，都不会导致类的初始化
		
class(类)
	以下，如果父类为接口时，子类初始化时，父类并不会初始化
	编译阶段可以确认值
		1. 对于静态变量，只有直接定义了该字段的类才会初始化（如：child继承parent，直接访问parent中的静态变量，child并不会初始化）,
			 直接访问子类字段时，在初始化子类的同时，会要求其父类（父类为接口除外）要全部初始化完毕（如：访问child的静态变量，会导致perent初始化）。
		2. 对于常量（fianl修饰），在编译阶段会存入调用这个常量的方法所在类的常量池中（如：
			 class1 中的test的方法调用class2中的常量str，那么class2中的这个str会存入class1的常量池）      
			 本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量类的初始化                                     
		   注意：这里指的是将常量存放到了class1中，之后class2就和class1就没有任何关系了，甚至，可以将class2的class文件删除。   
	编译阶段不可以确认值
		1. 对于静态变量，只有定义了该字段的类才会初始化；直接访问子类字段时，在初始化子类的同时，会要求其父类要全部初始化完毕（和编译阶段可以确认值相同）
		2. 当一个常量并非在编译阶段可以确定的，那么其值就不会存放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量的类，就会导致这个类的初始化
interface(接口)
	编译阶段可以确认值
		1. 子类（和父类）都不会初始化。见：类-编译阶段可以确认值-2
	编译阶段不可以确认值
		1. 子类的初始化，并不会导致父类的初始化。

对于数组类型来说，其类型是由JVM运行期间动态生成的，这种形式，动态生成的类型，其父类都是Object          
对于数组来说，JavaDoc经常将构成数组的元素称为Component,实际上就是将数组降低一个维度后的类型      